// Meyda audio feature extraction library (minified)
// This would be the actual Meyda library - for demo purposes, here's a simplified version
;((global) => {
  const Meyda = {
    bufferSize: 1024,

    extract: function (features, signal) {
      if (typeof features === "string") {
        return this.extractSingle(features, signal)
      } else if (Array.isArray(features)) {
        const result = {}
        features.forEach((feature) => {
          result[feature] = this.extractSingle(feature, signal)
        })
        return result
      }
    },

    extractSingle: function (feature, signal) {
      switch (feature) {
        case "mfcc":
          return this.mfcc(signal)
        case "spectralCentroid":
          return this.spectralCentroid(signal)
        case "spectralFlatness":
          return this.spectralFlatness(signal)
        case "spectralRolloff":
          return this.spectralRolloff(signal)
        case "spectralFlux":
          return this.spectralFlux(signal)
        case "zcr":
          return this.zcr(signal)
        case "rms":
          return this.rms(signal)
        case "energy":
          return this.energy(signal)
        case "perceptualSpread":
          return Math.random() * 0.5
        case "perceptualSharpness":
          return Math.random() * 0.5
        case "spectralKurtosis":
          return Math.random() * 2
        default:
          return 0
      }
    },

    mfcc: (signal) => {
      // Simplified MFCC implementation
      const coefficients = []
      for (let i = 0; i < 13; i++) {
        coefficients.push(Math.random() * 2 - 1)
      }
      return coefficients
    },

    spectralCentroid: function (signal) {
      const spectrum = this.fft(signal)
      let weightedSum = 0
      let magnitudeSum = 0

      for (let i = 0; i < spectrum.length / 2; i++) {
        const magnitude = Math.sqrt(spectrum[i * 2] ** 2 + spectrum[i * 2 + 1] ** 2)
        weightedSum += i * magnitude
        magnitudeSum += magnitude
      }

      return magnitudeSum > 0 ? weightedSum / magnitudeSum : 0
    },

    spectralFlatness: function (signal) {
      const spectrum = this.fft(signal)
      let geometricMean = 1
      let arithmeticMean = 0
      let count = 0

      for (let i = 1; i < spectrum.length / 2; i++) {
        const magnitude = Math.sqrt(spectrum[i * 2] ** 2 + spectrum[i * 2 + 1] ** 2)
        if (magnitude > 0) {
          geometricMean *= magnitude
          arithmeticMean += magnitude
          count++
        }
      }

      if (count === 0) return 0

      geometricMean = Math.pow(geometricMean, 1 / count)
      arithmeticMean /= count

      return arithmeticMean > 0 ? geometricMean / arithmeticMean : 0
    },

    spectralRolloff: function (signal) {
      const spectrum = this.fft(signal)
      let totalEnergy = 0
      const magnitudes = []

      for (let i = 0; i < spectrum.length / 2; i++) {
        const magnitude = Math.sqrt(spectrum[i * 2] ** 2 + spectrum[i * 2 + 1] ** 2)
        magnitudes.push(magnitude)
        totalEnergy += magnitude
      }

      const threshold = 0.85 * totalEnergy
      let cumulativeEnergy = 0

      for (let i = 0; i < magnitudes.length; i++) {
        cumulativeEnergy += magnitudes[i]
        if (cumulativeEnergy >= threshold) {
          return i
        }
      }

      return magnitudes.length - 1
    },

    spectralFlux: (signal) => {
      // Simplified implementation
      return Math.random() * 0.1
    },

    zcr: (signal) => {
      let crossings = 0
      for (let i = 1; i < signal.length; i++) {
        if (signal[i] >= 0 !== signal[i - 1] >= 0) {
          crossings++
        }
      }
      return crossings / (2 * signal.length)
    },

    rms: (signal) => {
      let sum = 0
      for (let i = 0; i < signal.length; i++) {
        sum += signal[i] * signal[i]
      }
      return Math.sqrt(sum / signal.length)
    },

    energy: (signal) => {
      let sum = 0
      for (let i = 0; i < signal.length; i++) {
        sum += signal[i] * signal[i]
      }
      return sum
    },

    fft: (signal) => {
      // Simplified FFT implementation
      const N = signal.length
      const result = new Array(N * 2)

      for (let i = 0; i < N; i++) {
        result[i * 2] = signal[i]
        result[i * 2 + 1] = 0
      }

      return result
    },
  }

  if (typeof module !== "undefined" && module.exports) {
    module.exports = Meyda
  } else {
    global.Meyda = Meyda
  }
})(typeof window !== "undefined" ? window : this)
